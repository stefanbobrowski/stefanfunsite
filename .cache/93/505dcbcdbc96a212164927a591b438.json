{"id":"../node_modules/hookrouter/dist/controlledInterceptor.js","dependencies":[{"name":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\package.json","includedInParent":true,"mtime":1584470154891},{"name":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\hookrouter\\package.json","includedInParent":true,"mtime":1567633600147},{"name":"react","loc":{"line":8,"column":44},"parent":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\hookrouter\\dist\\controlledInterceptor.js","resolved":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\react\\index.js"},{"name":"./interceptor","loc":{"line":10,"column":27},"parent":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\hookrouter\\dist\\controlledInterceptor.js","resolved":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\hookrouter\\dist\\interceptor.js"},{"name":"./router","loc":{"line":12,"column":22},"parent":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\hookrouter\\dist\\controlledInterceptor.js","resolved":"C:\\Users\\stefa\\Desktop\\FutureWebApps\\stefansite\\node_modules\\hookrouter\\dist\\router.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useControlledInterceptor = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _interceptor = require(\"./interceptor\");\n\nvar _router = require(\"./router\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\nvar useControlledInterceptor = function useControlledInterceptor() {\n  var _React$useState = _react.default.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      interceptedPath = _React$useState2[0],\n      setInterceptedPath = _React$useState2[1];\n\n  var interceptorFunction = _react.default.useMemo(function () {\n    return function (currentPath, nextPath) {\n      setInterceptedPath(nextPath);\n      return currentPath;\n    };\n  }, [setInterceptedPath]);\n\n  var stopInterception = (0, _interceptor.useInterceptor)(interceptorFunction);\n\n  var confirmNavigation = _react.default.useMemo(function () {\n    return function () {\n      stopInterception();\n      (0, _router.navigate)(interceptedPath);\n    };\n  }, [stopInterception, interceptedPath]);\n\n  var resetPath = _react.default.useMemo(function () {\n    return function () {\n      return setInterceptedPath(null);\n    };\n  }, [setInterceptedPath]);\n\n  return [interceptedPath, confirmNavigation, resetPath, stopInterception];\n};\n\nexports.useControlledInterceptor = useControlledInterceptor;\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/controlledInterceptor.js"],"names":["useControlledInterceptor","React","useState","interceptedPath","setInterceptedPath","interceptorFunction","useMemo","currentPath","nextPath","stopInterception","confirmNavigation","resetPath"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;AAUO,IAAMA,wBAAwB,GAAG,SAA3BA,wBAA2B,GAAM;AAAA,wBACCC,eAAMC,QAAN,CAAe,IAAf,CADD;AAAA;AAAA,MACtCC,eADsC;AAAA,MACrBC,kBADqB;;AAG7C,MAAMC,mBAAmB,GAAGJ,eAAMK,OAAN,CAC3B;AAAA,WAAM,UAACC,WAAD,EAAcC,QAAd,EAA2B;AAChCJ,MAAAA,kBAAkB,CAACI,QAAD,CAAlB;AACA,aAAOD,WAAP;AACA,KAHD;AAAA,GAD2B,EAK3B,CAACH,kBAAD,CAL2B,CAA5B;;AAQA,MAAMK,gBAAgB,GAAG,iCAAeJ,mBAAf,CAAzB;;AAEA,MAAMK,iBAAiB,GAAGT,eAAMK,OAAN,CACzB;AAAA,WAAM,YAAM;AACXG,MAAAA,gBAAgB;AAChB,4BAASN,eAAT;AACA,KAHD;AAAA,GADyB,EAKzB,CAACM,gBAAD,EAAmBN,eAAnB,CALyB,CAA1B;;AAQA,MAAMQ,SAAS,GAAGV,eAAMK,OAAN,CACjB;AAAA,WAAM;AAAA,aAAMF,kBAAkB,CAAC,IAAD,CAAxB;AAAA,KAAN;AAAA,GADiB,EAEjB,CAACA,kBAAD,CAFiB,CAAlB;;AAKA,SAAO,CAACD,eAAD,EAAkBO,iBAAlB,EAAqCC,SAArC,EAAgDF,gBAAhD,CAAP;AACA,CA3BM","sourcesContent":["import React from 'react';\r\nimport {useInterceptor} from \"./interceptor\";\r\nimport {navigate} from \"./router\";\r\n\r\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\r\nexport const useControlledInterceptor = () => {\r\n\tconst [interceptedPath, setInterceptedPath] = React.useState(null);\r\n\r\n\tconst interceptorFunction = React.useMemo(\r\n\t\t() => (currentPath, nextPath) => {\r\n\t\t\tsetInterceptedPath(nextPath);\r\n\t\t\treturn currentPath;\r\n\t\t},\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\tconst stopInterception = useInterceptor(interceptorFunction);\r\n\r\n\tconst confirmNavigation = React.useMemo(\r\n\t\t() => () => {\r\n\t\t\tstopInterception();\r\n\t\t\tnavigate(interceptedPath);\r\n\t\t},\r\n\t\t[stopInterception, interceptedPath]\r\n\t);\r\n\r\n\tconst resetPath = React.useMemo(\r\n\t\t() => () => setInterceptedPath(null),\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\treturn [interceptedPath, confirmNavigation, resetPath, stopInterception];\r\n};\r\n"]}},"error":null,"hash":"f41ab3b1063ad23d37c251222ae127ed","cacheData":{"env":{}}}